{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"getting-started/","title":"Getting Started","text":"<p>Implementing your own nextflow pipeline for you research on cellular dynamics in cell monolayers is easy. This guide will shortly explain how to get started.</p>"},{"location":"getting-started/#prerequesites","title":"Prerequesites","text":"<p>What you'll need: 1. nextflow installation 2. miniforge [^1] 3. the <code>cmot-pipeline</code> python environment as defined in <code>environment.yml</code> [^2] 4. The <code>cellular-dynamics-nf-modules</code> repository downloaded in your project folder, e.g.</p> <pre><code>Your Project/\n\u2502\n\u251c\u2500\u2500 pipeline.nf\n\u2502\n\u251c\u2500\u2500 nextflow.config\n\u2502\n\u2514\u2500\u2500 cellular-dynamics-nf-modules/\n    \u251c\u2500\u2500 modules/\n    \u251c\u2500\u2500 docs/\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"getting-started/#simple-pipeline-example","title":"Simple Pipeline Example","text":""},{"location":"getting-started/#defining-the-pipeline-steps","title":"Defining the Pipeline Steps","text":"<p>In this section we develop a short pipeline that 1. loads our data 2. segments the nuclei (see <code>nuclei_segmentation</code> module) 3. runs the cell approximation (see <code>cell_approximation</code> module)</p> <p>In the pipeline definition (<code>pipeline.nf</code>) we start by importing the pre-defined nextflow processes <code>nuclei_segmentation</code> and <code>cell_approximation</code>:</p> <pre><code>include { nuclei_segmentation } from './cellular-dynamics-nf-modules/modules/image_processing/nuclei_segmentation/main.nf'\ninclude { cell_approximation } from './cellular-dynamics-nf-modules/modules/image_processing/cell_approximation/main.nf'\n</code></pre> <p>Next, we define a process that will read the raw image files and stores them in an instance of the <code>python</code>-class <code>BaseDataSet</code>. This class is defined in the <code>core-data-utils</code> repository which provides the basic framework for reading, storing and manipulating any kind of data we might need in our pipeline.</p> <p>Create a new <code>python</code>-script called <code>prepare_data.py</code> with content similar to</p> <pre><code>from argparse import ArgumentParser\n\nimport cv2\nfrom core_data_utils.datasets import BaseDataSet, BaseDataSetEntry\nfrom core_data_utils.datasets.image import ImageDataset\n\n\nif __name__ == \"__main__\":\n\n    cv2.setNumThreads(0)\n\n    parser = ArgumentParser()\n    parser.add_argument(\"--indir\", type=str, required=True)\n    parser.add_argument(\"--outfile\", type=str, required=True)\n\n    args = parser.parse_args()\n\n    # this will read all images in the directory 'args.indir' and store them in 'x'\n    x = ImageDataSet.from_directory(args.indir)\n\n    # write dataset 'x' to disk via pickle\n    x.to_pickle(args.outfile)\n</code></pre> <p>To call this script in our <code>nextflow</code> pipeline, define a new process in <code>pipeline.nf</code>:</p> <pre><code>process prepare_dataset{\n\n    label \"low_cpu\", \"short_running\" // can be used to control the amount of resources allocated for process by SLURM\n\n    // define what inputs the process requires\n    input:\n    tuple val(basename), path(dataset_path)\n\n    // define what the process will output\n    output:\n    tuple val(basename), path(\"original_dataset.pickle\"), emit: results\n\n    /*\n    define what bash-script will be executed, in this case we simply call\n    our python script 'prepare_dataset.py' and suppy it with the\n    process's input arguments as 'command line arguments' (that's why we need\n    an ArgumentParser in the python script).\n    */\n    script:\n    \"\"\"\n    python ${projectDir}/scripts/prepare_dataset.py \\\n        --indir=\"${dataset_path}\" \\\n        --outfile=\"original_dataset.pickle\"\n    \"\"\"\n}\n</code></pre> <p>With this preliminary process in place we can define the full pipeline:</p> <pre><code>\nworkflow {\n    // we create a queue-channel listing all dataset directories inside a common parent directory (params.parent_indir)\n    // params.parent_indir can be supplied either via a config file or directly be specified\n    input_datasets = Channel.fromPath(file(params.parent_indir).resolve(params.in_dir).toString(), type: \"dir\")\n\n    // Transform the channel to emit both the directory and its basename\n    // This creates a tuple channel: [dir, basename]\n    input_datasets = input_datasets.map { dir -&gt;\n        def basename = dir.name\n        [basename, dir]\n    }\n\n    // prepare datasets:\n    prepare_dataset(input_datasets)\n\n    /* the output of prepare_datasets is the input for the nuclei_segmentation\n    in addition to the prepared dataset pickle file which is output by the previous process\n    we also need to specify:\n        1. the stardist probability threshold\n        2. minimum nucleus area (in px^2)\n        3. the directory to which the output should be published\n    */\n    nuclei_segmentation(prepare_dataset.out.results, 0.473, ...)\n\n    /* the output of the nuclei segmentation is then fed to the 'cell_approximation'\n    process: (for a more detailed documentation of the input parameters the processes expect see\n    the corresponding module documentation)\n    */\n    cell_approximation(nuclei_segmentation.out.results, cell_cutoff_px, parent_dir_out)\n}\n\n</code></pre>"},{"location":"getting-started/#run-the-example-pipeline","title":"Run the Example Pipeline","text":"<p>To run the pipeline, run the following command from the directory the <code>pipeline.nf</code> file resides in:</p> <pre><code>nextflow run ./pipeline.nf\n</code></pre> <p>[^1]: or another python distribution that comes with <code>conda</code> or <code>mamba</code> [^2]: This environment contains all module dependencies. Depending on which ones you are planning to use some dependencies might not be needed.</p>"},{"location":"modules/","title":"Module Documentation","text":"<p>This repository currently contains the following groups of modules:</p> <ol> <li>image processing modules (<code>modules/image_processing</code>)</li> <li>tracking modules (<code>modules/tracking/</code>)</li> <li>graph processing modules (<code>modules/graph_processing</code>)</li> </ol>"},{"location":"modules/#image-processing-modules","title":"Image Processing Modules","text":""},{"location":"modules/#nuclei-segmentation","title":"Nuclei Segmentation","text":"<p>The <code>nuclei_segmentation</code> module provides a process that takes a <code>BaseDataSet</code> instance with confocal microscopy images (RGB)  showing stained nuclei as input. Subsequently, the images are grayscaled and re-scaled to the range <code>[0,1]</code> before nuclei are segmented via stardist.</p> <p>Import the module into your pipeline script via</p> <pre><code>include { nuclei_segmentation } from './cellular-dynamics-nf-modules/modules/image_processing/nuclei_segmentation/main.nf'\n</code></pre> Argument Index Argument Name Argument Type Description 1 tuple(val, path) (<code>basename</code>, <code>fpath</code>) 2 <code>stardist_probability_threshold</code> val Floating point number defining <code>stardist</code> probability threshold. 3 <code>min_nucleus_area_pxsq</code> val Floating point number defining the minimum nucleus area (in \\(px^2\\)!). Segmented objects smaller than this will be removed. 4 <code>parent_dir_out</code> val Directory to which the resulting file will be published."},{"location":"modules/#basic-filter","title":"Basic Filter","text":""},{"location":"modules/#cell-approximation","title":"Cell Approximation","text":""},{"location":"modules/#label-objects","title":"Label Objects","text":""},{"location":"modules/#nucleus-displacement-index-nusdi","title":"Nucleus Displacement Index (NusDI)","text":"<p>The nucleus displacement index (NusDI) is defined to be the ratio of the distance of the nucleus centroid from the corresponding cell's centroid (\\(\\lambda_\\text{0}\\)) over the maximum possible distance (\\(\\lambda_\\text{max}\\)) of the two centroids. This maximum possible distance will be determined by converting the cell and nucleus outline to polygons (<code>shapely.Polygon</code>) and trying a plethora of nucleus configurations (translations &amp; rotations).</p> <p>\\(\\delta_\\text{NusDI} = \\frac{\\lambda_\\text{0}}{\\lambda_\\text{max}}\\)</p>"},{"location":"modules/#inputs","title":"Inputs:","text":"Argument Index Argument Name Argument Type Description 1 tuple(val, path, path, path) (<code>basename</code>, labelled nuclei, labelled cells, graphs) 2 <code>parent_dir_out</code> val Directory to which the resulting file will be published."},{"location":"modules/#outputs","title":"Outputs:","text":"Argument Index Argument Name Argument Type Description 1 tuple(val, path) (<code>basename</code>, graph dataset with NusDI annotations)"},{"location":"modules/#tracking-modules","title":"Tracking Modules","text":""},{"location":"modules/#annotate-d2_textmin","title":"Annotate \\(D^2_\\text{min}\\)","text":"<p>The <code>annotate_D2min</code> module provides a process that calculates the cell motility measure \\(D_\\text{min}^2\\). This measure quantifies non-affine movements of cells with regard to their neighbors by optimizing the strain tensor \\(\\pmb{E}\\):</p> <p>\\(D^2_{\\text{min}, i} = \\text{min} \\left[\\frac{1}{N} \\sum_{j \\in \\mathcal{N}_i} \\left(\\pmb{r}_{i,j}(t+T) - \\pmb{E}_i \\pmb{r}_{i,j}(t) \\right) \\right]\\)</p> <p>Import the module into your pipeline script via</p> <pre><code>include { annotate_D2min } from './cellular-dynamics-nf-modules/modules/tracking/annotate_D2min/main.nf'\n</code></pre> Argument Index Argument Name Argument Type Description 1 tuple(val, path) (<code>basename</code>, <code>graph_dataset_fpath</code>) 2 <code>delta_t_minutes</code> val Floating point number defining the time (\\(\\Delta t\\)) between two adjacent frames. 3 <code>lag-times_minutes</code> val String of comma-separated lag times (in minutes) the \\(D^2_\\text{min}\\) measure should be calculated for. 4 <code>mum_per_px</code> val Floating point number defining the image resolution in microns per pixel (\\(\\frac{\\mu m}{\\text{px}}\\)) 5 <code>minimum_neighbors</code> val Integer defining the minimum number of successfully tracked neighbors needed for calculating \\(D^2_\\text{min}\\). This should always be <code>2</code> or more. 6 <code>parent_dir_out</code> val Directory to which the resulting file will be published."},{"location":"modules/#annotate-cage-relative-squared-displacement","title":"Annotate Cage-Relative Squared Displacement","text":"<p>The <code>cage_relative_squared_displacement</code> module calculates the cage-relative squared displacement (CRSD) defined as:</p> <p>\\(\\text{CRSD}_i = \\left[ \\pmb{x}_i (t+\\tau) - \\pmb{x}_i (t) - \\left\\langle \\pmb{x}_j (t+\\tau) - \\pmb{x}_j (t) \\right\\rangle_{j\\in \\mathcal{N}(i)}\\right]^2\\)</p> <p>with \\(\\left\\langle \\pmb{x}_j (t+\\tau) - \\pmb{x}_j (t) \\right\\rangle_{j\\in \\mathcal{N}(i)}\\) being the mean displacement vector of cell \\(i\\)'s neighbors.</p>"},{"location":"modules/#inputs_1","title":"Inputs:","text":"Argument Index Argument Name Argument Type Description 1 tuple(val, path) (<code>basename</code>, <code>graph_dataset_fpath</code>) 2 <code>delta_t_minutes</code> val Floating point number defining the time (\\(\\Delta t\\)) between two adjacent frames. 3 <code>lag-times_minutes</code> val String of comma-separated lag times (in minutes) the CRSD measure should be calculated for. 4 <code>mum_per_px</code> val Floating point number defining the image resolution in microns per pixel (\\(\\frac{\\mu m}{\\text{px}}\\)) 5 <code>parent_dir_out</code> val Directory to which the resulting file will be published."},{"location":"modules/#outputs_1","title":"Outputs:","text":"Argument Index Argument Name Argument Type Description 1 tuple(val, path) (<code>basename</code>, graph dataset with CRSD annotations)"},{"location":"modules/#annotate-neighbor-retention","title":"Annotate Neighbor Retention","text":""},{"location":"modules/#cell-tracking-overlap-tracking","title":"Cell Tracking (Overlap Tracking)","text":""},{"location":"modules/#assemble-cell-tracks-dataframe","title":"Assemble Cell Tracks DataFrame","text":""},{"location":"modules/#concatenate-tracking-dataframes","title":"Concatenate Tracking DataFrames","text":"<p>This module combines the tracking dataframes from all processed datasets into a single big dataframe. The cell track IDs are adjusted such that they remain unique in the dataframe.</p>"},{"location":"modules/#inputs_2","title":"Inputs:","text":"Argument Index Argument Name Argument Type Description 1 val <code>tracking_df_files_list</code> 2 <code>parent_dir_out</code> val Directory to which the resulting file will be published."},{"location":"modules/#outputs_2","title":"Outputs:","text":"Argument Index Argument Name Argument Type Description 1 path <code>\"all_cell_tracks.ipc\"</code>"},{"location":"modules/#graph-processing-modules","title":"Graph Processing Modules","text":""},{"location":"modules/#structure-abstraction","title":"Structure Abstraction","text":""},{"location":"modules/#build-graphs","title":"Build Graphs","text":""},{"location":"modules/#annotate-graph-theoretical-observables","title":"Annotate Graph Theoretical Observables","text":""},{"location":"modules/#calculate-local-density","title":"Calculate Local Density","text":"<p>A cell's local density \\(\\rho\\) is defined to be the inverse of the mean cell area \\(\\bar{A}\\) of the cell and its neighbors:</p> <p>\\(\\rho_i = \\frac{1}{\\bar{A}} = \\frac{1}{\\frac{1}{|\\mathcal{N_i}| + 1} \\left(A_i + \\sum_{j \\in \\mathcal{N_i} }A_j\\right)}\\)</p> <pre><code>include { calculate_local_density } from './cellular-dynamics-nf-modules/modules/graph_processing/calculate_local_density/main.nf'\n</code></pre>"},{"location":"modules/#inputs_3","title":"Inputs:","text":"Argument Index Argument Name Argument Type Description 1 tuple(val, path) (<code>basename</code>, <code>fpath</code>) 2 <code>parent_dir_out</code> val Directory to which the resulting file will be published."}]}